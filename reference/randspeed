#!/bin/bash
#
# https://www.guyrutenberg.com/2020/08/23/quickly-generate-lots-of-random-data/
# https://superuser.com/a/793003/68321
#
# AES-128 CTR chosen as AES is Hardware-accelerated on most modern CPUs (~2015)
#
# Check algoritms performance with `openssl speed [-evp] [ALGO...]`
# 14.30GiB/s: pv -B 1M /dev/zero > /dev/null
#  4.15GiB/s: pv -B 1M /dev/zero | cat > /dev/null
#

size=${1:-10G}
benchmark=${2:-dd}

# ---------------------

benchmark_pv() {
	pv -B 4M -Ss "$size" > /dev/null
}

benchmark_dd() {
	dd of=/dev/null bs=1M iflag=fullblock,count_bytes count="$size" status=progress
}

message() {
	printf '\n%s\n' "$@"
}

# ---------------------

devzero() {
	cat /dev/zero
}

devurandom() {
	cat /dev/urandom
}

# ---------------------

openssl_ciphers() {
	openssl enc -ciphers | awk 'NF==3{print($1 "\n"  $2 "\n" $3)}'
}

openssl_fast_ciphers() {
	# AES ECB is faster but not suitable for most needs
	printf '%s\n' aes-{128,192,256}-ctr chacha20
}

opensslenc() {
	openssl enc "$@" -pbkdf2 \
	  -pass pass:"$(dd if=/dev/urandom bs=128 count=1 status=none | base64)" \
	  < /dev/zero \
	  2> /dev/null  # avoid 'error writing file' when benchmark closes pipe
	# can also be fixed with `head -c "$size" /dev/zero | openssl ...`,
	# at a ~10% performance hit
}

openssl_none() {
	opensslenc -none
}

openssl_fastest() {
	opensslenc -aes-128-ctr  # ~1,84GiB/s (ecb is ~1,88GiB/s)
}


# ---------------------

benchmark=benchmark_$benchmark

message "Theoretical limit: /dev/zero with no pipes"
"$benchmark" < /dev/zero

message "Reference: /dev/zero"
devzero | "$benchmark"

# Too slow!
#message "/dev/urandom"
#devurandom | "$benchmark"

message "OpenSSL none"
openssl_none | "$benchmark"

while IFS= read -r cipher; do
	message "OpenSSL $cipher"
	opensslenc -"$cipher" | "$benchmark"
done < <(openssl_fast_ciphers)
