# Commands meant to run at every shell
#
# To be sourced by ~/.bashrc
#
# To run, add these lines to ~/.bashrc:
#
#	if [ -f "$SCRIPTS/home/bashrc" ] ; then
#	    . "$SCRIPTS/home/bashrc"
#	fi

# Supporting Functions (for scripts, not terminal, those go to bash_aliases) ---

relpath() { python -c "import os,sys;print os.path.relpath(*sys.argv[1:3])" "$@"; }
exists()  { type "$@" >/dev/null 2>&1; }

# ------------------------------------------------------------------------------

# Enable bash-completion, if not already enabled by ~/.bashrc
if	[ -z "${BASH_COMPLETION_VERSINFO:-}" ] &&
	[ -f /usr/share/bash-completion/bash_completion ] &&
	! shopt -oq posix
then
	source /usr/share/bash-completion/bash_completion
fi

if [ -f "$SCRIPTS/home/bash_aliases" ] ; then
	source "$SCRIPTS/home/bash_aliases"
fi

if [ -f "$HOME/work/wine-tools/wine-tools-bashrc" ] ; then
	source "$HOME/work/wine-tools/wine-tools-bashrc"
fi

if [ -f "$HOME/work/dosbox/dosbox-tools/dosbox-bashrc" ] ; then
	source "$HOME/work/dosbox/dosbox-tools/dosbox-bashrc"
fi

# PS1 customization ------------------------------------------------------------
# http://bashrcgenerator.com/

declare -A C=(
   [RED]="\[\e[1;31m\]"  # "\[$(tput bold; tput setaf 1)\]"
 [GREEN]="\[\e[1;32m\]"  # "\[$(tput bold; tput setaf 2)\]"
  [BLUE]="\[\e[1;34m\]"  # "\[$(tput bold; tput setaf 4)\]"
[YELLOW]="\[\e[1;33m\]"  # "\[$(tput bold; tput setaf 3)\]"
[PURPLE]="\[\e[1;35m\]"  # "\[$(tput bold; tput setaf 5)\]"
 [WHITE]="\[\e[1;37m\]"  # "\[$(tput bold; tput setaf 7)\]"
 [RESET]="\[\e[0m\]"     # "\[$(tput sgr0)\]"
)

# Alternative: \${?/#0/} directly into PS1, but lacks surrounding spaces
__status() {
	local s=$?
	(($s)) && printf '%s ' "$s"
	return $s
}

# See /usr/lib/git-core/git-sh-prompt
export GIT_PS1_SHOWDIRTYSTATE=1
export GIT_PS1_SHOWSTASHSTATE=1
export GIT_PS1_SHOWUNTRACKEDFILES=1

# __git_ps1() is transitioning away from git bash completion
# See /etc/bash_completion.d/git-prompt
if ! exists __git_ps1; then
	if [[ -r /usr/lib/git-core/git-sh-prompt ]]; then
		source /usr/lib/git-core/git-sh-prompt
	else
		# Simpler version
		__git_ps1() {
			local s=$?
			git branch 2>/dev/null | grep '^*' | sed 's/* \(.*\)/\1 /'
			return "$s"
		}
	fi
fi

PS1="${C[RESET]}${C[PURPLE]}\t ${C[GREEN]}\u@\h ${C[BLUE]}\w "\
"${C[RED]}\$(__git_ps1 '%s ')${C[YELLOW]}\$(__status)${C[BLUE]}\$ ${C[RESET]}"

unset C

# ------------------------------------------------------------------------------

# Disable the dreaded history expansion for interactive sessions
# A.K.A 'why echo "Hello World!" do not work?'
set +o histexpand # same as set +H

# Create core dump files on segmentation fault. File `core` at current process dir
#ulimit -c unlimited

# Functions (should be moved to bash_aliases)-----------------------------------

mv-link() (
	local newdir=$1
	local msg1="Move all symlinks from current dir to another path, and make them relative"
	local msg2="Usage: mv-link DESTDIR"
	[[ "$newdir" ]] || { printf '%s\n%s\n' "$msg1" "$msg2"; return 1; }
	while read -r link; do
		ln -s "$(relpath "$(readlink -n "$link")" "$newdir")" \
			"$newdir/$(basename "$link")" &&
		rm "$link"
	done < <(find "." -maxdepth 1 -type l)
)

# Minecraft
_minecraft_saverestore() {
	local src=$HOME/.minecraft/saves
	local dst=$HOME/install/minecraft/saves/minecraft-auto/saves
	local mode=${1:-save}
	if [[ "$mode" == "restore" ]]; then
		local tmp=$src
		src=$dst
		dst=$tmp
	fi
	[[ -d "$src" ]] || { echo "$src does not exist" >&2; return 1; }
	rm -rf   -- "$dst".bak     &&   # Delete destination backup, if exists
	mkdir -p -- "$dst"         &&   # Create destination
	mv       -- "$dst"{,.bak}  &&   # Backup destination
	cp -r    -- "$src" "${dst%/*}"  # Copy Source to Destination
}
minecraft-save()    { _minecraft_saverestore save;    }
minecraft-restore() { _minecraft_saverestore restore; }

# ------------------------------------------------------------------------------

# So cute!
exists cowfortune && cowfortune | { exists lolcat && lolcat || cat; }
