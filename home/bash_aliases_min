# Minimal quality-of-life aliases and settings, including PS1
# Save as ~/.bash_aliases

# ------------------------------------------------------------------------------

# SP  ' '  0x20 = · U+00B7 Middle Dot
# TAB '\t' 0x09 = ￫ U+FFEB Halfwidth Rightwards Arrow
# CR  '\r' 0x0D = § U+00A7 Section Sign (⏎ U+23CE also works fine)
# LF  '\n' 0x0A = ¶ U+00B6 Pilcrow Sign (was "Paragraph Sign")
alias whitespace="sed 's/ /·/g;s/\t/￫/g;s/\r/§/g;s/$/¶/g'"
alias ls="ls --color=auto --group-directories-first -1"
alias ll="ls -l --time-style=long-iso"
alias la="ll -A"
alias path="echo \$PATH"
alias fstab="sudo nano /etc/fstab"
alias open="xdg-open"
alias trash="trash-put"  # requires trash-cli package
alias rm="trash"
alias dd-progress="dd status=progress bs=1M iflag=count_bytes"
alias dd-nocache="dd-progress oflag=nocache,sync"
alias dfd='df -H -x tmpfs -x squashfs -x devtmpfs'
alias duh='du -sbh --si'
alias dud='lsblk --exclude 7'  # 7 = loop devices, most likely snaps
alias rot13="tr 'A-Za-z' 'N-ZA-Mn-za-m'"
alias json='python3 -m json.tool'  # 'jq' is a beter alternative, if installed
alias why='apt rdepends --installed'  # can also be 'aptitude why'

exists()  { type "$@" &>/dev/null; }
where()   { dpkg --search -- $(type -p "${1:-}"); }
cdl()     { cd "$@" && ll ; }
md()      { mkdir "$@" && cd "${@: -1}" ; }
compile() { gcc -Wall -Wextra -o "${1%.*}" "$@"; }
dmesgw()  { watch -n 0.25 "dmesg $@ | tail -n $((LINES-3))"; }
epoch()   { date -d@"$1" ; }
now()     { date +%Y%m%d%H%M%S ; }
timestamp() {
	if [[ "${1:-}" ]]; then
		date +%s --date "$1"
	else
		date +%s
	fi
}

cmdlist() { type -a "$1"; ll "$(type -P "$1")" ; }
cmdcat()  { cat  "$(type -P "$1")" ; }
cmdopen() { open "$(type -P "$1")" ; }

install_packages() {
	# Avoid marking installed packages as manual by only installing missing ones
	local pkg=
	local pkgs=()
	for pkg in "$@"; do
		if ! package_installed "$pkg"; then pkgs+=( "$pkg" ); fi
	done
	if (("${#pkgs[@]}")); then
		sudo apt install "${pkgs[@]}"
	fi
}
package_version() {
	dpkg-query --showformat='${Version}' --show "$1" 2>/dev/null
}
package_installed() {
	local ok
	ok=$(package_version "$1") && [[ "$ok" ]]
}

# 1337!
matrix() {
	tr -c "[:digit:]" " " < /dev/urandom |
	dd cbs=$COLUMNS conv=unblock |
	GREP_COLOR="1;32" grep --color "[^ ]"
}


# ------------------------------------------------------------------------------

# copies a completion definition for a command to other command(s)
complete-copy() {
	local cmd="$1"
	shift
	if complete -p "$cmd" &>/dev/null &&
	   type "$@"          &>/dev/null
	then
		eval $(complete -p "$cmd") "$@"
	fi
}

complete -c where cmdlist cmdcat cmdopen        # commands (executables in $PATH)
complete -F _comp_pkg_names ubuntu-package why  # packages in repositories
complete-copy ls ll la
complete-copy dwww-man mand package


# PS1 customization ------------------------------------------------------------
# http://bashrcgenerator.com/

# Print exit code of last command if non-zero, and return it
# Blank if 0, otherwise use $1 as formatting string, '%s ' by default
# Return the same code, to preserve it between prompts
# Alternative: \${?/#0/} directly into PS1, but lacks surrounding spaces
_format_exitcode() {
	local s=$?
	(($s)) && printf "${1:-%s }" "$s"
	return $s
}

# Git Status
# See /usr/lib/git-core/git-sh-prompt
export GIT_PS1_SHOWDIRTYSTATE=1
export GIT_PS1_SHOWSTASHSTATE=1
export GIT_PS1_SHOWUNTRACKEDFILES=1
if ! exists __git_ps1; then
	# __git_ps1() is transitioning away from git bash completion
	# See /etc/bash_completion.d/git-prompt
	if [[ -r /usr/lib/git-core/git-sh-prompt ]]; then
		source /usr/lib/git-core/git-sh-prompt
	else
		# Simpler version
		__git_ps1() {
			local s=$?
			if exists git; then
				git branch 2>/dev/null |
				grep '^*' |
				sed 's/* \(.*\)/\1 /'
			fi
			return "$s"
		}
	fi
fi

# Colors
# '\[' and '\]' are for PS1, not colors: https://mywiki.wooledge.org/BashFAQ/053
color() { printf '\['; tput setaf "${1:-15}"; printf '\]'; }
declare -A c=(
	 [BLACK]=$(color 0)  # "\[\e[30m\]"
	   [RED]=$(color 1)  # "\[\e[31m\]"
	 [GREEN]=$(color 2)  # "\[\e[32m\]"
	[YELLOW]=$(color 3)  # "\[\e[33m\]"
	  [BLUE]=$(color 4)  # "\[\e[34m\]"
	[PURPLE]=$(color 5)  # "\[\e[35m\]"
	  [CYAN]=$(color 6)  # "\[\e[36m\]"
	 [WHITE]=$(color 7)  # "\[\e[37m\]"
	  [BOLD]="\[$(tput bold)\]"  # "\[\e[1m\]"
	 [RESET]="\[$(tput sgr0)\]"  # "\[\e[0m\]"
)

# Final product
PS1=${c[RESET]}${c[BOLD]}\
"${c[PURPLE]}\t ${c[GREEN]}\u@\h ${c[BLUE]}\w "\
"${c[RED]}\$(__git_ps1 '%s ')${c[YELLOW]}\$(_format_exitcode)${c[BLUE]}\\$ "\
${c[RESET]}

unset color c


# Settings ---------------------------------------------------------------------

# Disable the dreaded history expansion for interactive sessions
# A.K.A 'why echo "foo!bar" do not work?' (but "foo!" and "foo! bar!" does)
set +o histexpand  # same as set +H

# ------------------------------------------------------------------------------

if   exists screenfetch; then screenfetch
elif exists neofetch;    then neofetch
elif exists cowfortune;  then
	cowfortune | { exists lolcat && lolcat || cat ; }  # So cute!
fi
