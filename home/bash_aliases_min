# Minimal quality-of-life aliases and settings, including PS1
# Save as ~/.bash_aliases
#	target=$(find "$HOME" -name bash_aliases_min)
#	ln -s "${target#"$HOME"/} "$HOME"/.bash_aliases
# -----------------------------------------------------------------------------

# For thousand separator in ls and friends
# could also use ls -l --block-size="'1" as alias (escaping the double-quotes)
# Setting env vars in ~/.bash_aliases only works for interactive shells.
# Use ~/.profile or ~/.pam_environment to properly set them.
export BLOCK_SIZE="'1"

# No more (poorly and half-) translated --help and man pages, please!
# https://www.gnu.org/software/gettext/manual/html_node/Locale-Environment-Variables.html
export LANGUAGE=en_US:en
export LC_ALL=en_US.UTF-8
export LC_NUMERIC=pt_BR.UTF-8  # might require sudo locale-gen pt_BR.UTF-8

# Aliases >>>>>----------------------------------------------------------------

# SP  ' '  0x20 = · U+00B7 Middle Dot
# TAB '\t' 0x09 = ￫ U+FFEB Halfwidth Rightwards Arrow
# CR  '\r' 0x0D = § U+00A7 Section Sign (⏎ U+23CE also works fine)
# LF  '\n' 0x0A = ¶ U+00B6 Pilcrow Sign (was "Paragraph Sign")
alias whitespace="sed 's/ /·/g;s/\t/￫/g;s/\r/§/g;s/$/¶/g'"
alias ls="ls --color=auto --group-directories-first -1"
alias ll="ls -l --time-style=long-iso"
alias la="ll -A"
alias path="echo \$PATH"
alias fstab="sudo nano /etc/fstab"
alias open="xdg-open"
alias trash="trash-put"  # requires trash-cli. Do NOT alias rm, affects functions
alias mand="dwww-man"    # requires dwww
alias dd-progress="dd status=progress bs=1M iflag=count_bytes"
alias dd-nocache="dd-progress oflag=nocache,sync"
alias dfd='df -H -x tmpfs -x squashfs -x devtmpfs'
alias duh='du -sbh --si'
alias dud='lsblk --exclude 7'  # 7 = loop devices, most likely snaps
alias rot13="tr 'A-Za-z' 'N-ZA-Mn-za-m'"
alias json='python3 -m json.tool'  # 'jq' is a beter alternative, if installed
alias why='apt rdepends --installed'  # can also be 'aptitude why'
alias dmesg="dmesg --follow"  # welcome 2021!

try()     { "$@" 2>/dev/null || :; }
where()   { dpkg --search -- $(type -p "${1:-}"); }
cdl()     { cd "$@" && ll ; }
md()      { mkdir "$@" && cd "${@: -1}" ; }
compile() { gcc -Wall -Wextra -o "${1%.*}" "$@"; }

_datefmt()  { [[ "$2" ]] && d=(-d"${3:-}${2}") || d=(); date "$1" "${d[@]}"; }
now()       { _datefmt '--rfc-3339=seconds' "${1:-}" '@'; }
timestamp() { _datefmt '+%Y%m%d%H%M%S'      "${1:-}" '@'; }
epoch()     { _datefmt '+%s'                "${1:-}"; }

ubuntu-package() { open "http://packages.ubuntu.com/search?searchon=names&suite=all&section=all&keywords=$1"; }

cmdlist() { type -a "$1"; ll "$(type -P "$1")" ; }
cmdcat()  { cat  "$(type -P "$1")" ; }
cmdopen() { open "$(type -P "$1")" ; }

rename-function() {
	# https://stackoverflow.com/a/34177402/624066
	if [[ $# != 2 ]]; then echo "rename-function ORIG NEW" >&2; return 1; fi
	local a; a="$(declare -f "$1")" &&
	eval "function $2 ${a#*"()"}" &&
	unset -f "$1"
}

apt-list-manual() {
	# https://askubuntu.com/a/492343/11015
	local manifest=${1:-}
	local initial=/var/log/installer/initial-status.gz
	local list=
	# User-provided manifest, assume same format as https://releases.ubuntu.com
	if [[ "$manifest" ]]; then
		list=$(awk '{print $1}' "$manifest") || {
			echo "Usage: apt-list-manual [MANIFEST-FILE]" >&2
			return
		}
	# List from system installer log
	elif [[ -f "$initial" ]]; then
		list=$(gzip -dc "$initial" | sed -n 's/^Package: //p')
	fi

	# List packages
	comm -23 <(apt-mark showmanual | sort -u) <(echo "$list" | sort -u)

	# If initial log not found and no manifest provided, show download instructions
	if [[ "$list" ]]; then
		return
	fi
	printf 'ERROR:' >&2

	# numeric version including with point release: 20.04.3
	local version=$(awk -F'="?| ' '/^VERSION=/{print $2}' /etc/*release)
	local msg=(
		"Empty or missing manifest file: ${manifest:-$initial}"
		"Is this a server? Without a manifest the above list is not accurate."
		"Download it from: http://releases.ubuntu.com/${version}/"
		"And try again with: apt-list-manual MANIFEST-FILE"
	)
	printf '\t%s\n' "${msg[@]}" >&2
}

install_packages() {
	# Avoid marking installed packages as manual by only installing missing ones
	local pkg=
	local pkgs=()
	for pkg in "$@"; do
		if ! package_installed "$pkg"; then pkgs+=( "$pkg" ); fi
	done
	if (("${#pkgs[@]}")); then
		sudo apt install "${pkgs[@]}"
	fi
}
package_version() {
	dpkg-query --showformat='${Version}' --show "$1" 2>/dev/null
}
package_installed() {
	local ok
	ok=$(package_version "$1") && [[ "$ok" ]]
}

dump-system-data() {
	local target=${1:-./system-data}
	local manifest=${2:-}
	mkdir -p -- "$target"
	try dconf dump /                          > "$target"/dconf.txt
	try cat /etc/fstab                        > "$target"/fstab.txt
	try cat /etc/apt/sources.list{,.d/*.list} > "$target"/apt-sources.txt
	try crontab -l                            > "$target"/crontab.txt
	apt-list-manual "$2"                      > "$target"/apt-packages.txt
	try sudo fdisk --list                     > "$target"/fdisk.txt
}

# Other aliases <<<<<----------------------------------------------------------

exists()  { type "$@" &>/dev/null; }
xtitle()  { printf '\e]2;%s\a' "$*"; }
snipfile(){ local n=${3:-5}; awk "/${2:-} *>{${n}}/,/<{${n}}/" "${1:-}"; }

# 1337!
matrix() {
	tr -c "[:digit:]" " " < /dev/urandom |
	dd cbs=$COLUMNS conv=unblock |
	GREP_COLOR="1;32" grep --color "[^ ]"
}

# Completion ------------------------------------------------------------------

# copies a completion definition for a command to other command(s)
complete-copy() {
	local cmd="$1"
	shift
	if complete -p "$cmd" &>/dev/null &&
	   type "$@"          &>/dev/null
	then
		eval $(complete -p "$cmd") "$@"
	fi
}
# package names
# See /usr/share/bash-completion/completions/apt-cache._apt_cache_packages()
_comp_pkg_names() {
        local cur; _get_comp_words_by_ref cur
        COMPREPLY=( $(apt-cache --no-generate pkgnames -- "$cur" 2>/dev/null) )
        return 0
}

complete -c where cmdlist cmdcat cmdopen        # commands (executables in $PATH)
complete -F _comp_pkg_names ubuntu-package why  # packages in repositories
complete-copy ls ll la
complete-copy dwww-man mand package


# PS1 customization >>>>>------------------------------------------------------
# http://bashrcgenerator.com/

# Print exit code of last command if non-zero, and return it
# Blank if 0, otherwise use $1 as formatting string, '%s ' by default
# Return the same code, to preserve it between prompts
# Alternative: \${?/#0/} directly into PS1, but lacks surrounding spaces
_format_exitcode() {
	local s=$?
	if (($s)); then printf "${1:-%s }" "$s"; fi
	return $s
}

# Git Status
# See /usr/lib/git-core/git-sh-prompt
export GIT_PS1_SHOWDIRTYSTATE=1
export GIT_PS1_SHOWSTASHSTATE=1
export GIT_PS1_SHOWUNTRACKEDFILES=1
if ! exists __git_ps1; then
	# __git_ps1() is transitioning away from git bash completion
	# See /etc/bash_completion.d/git-prompt
	if [[ -r /usr/lib/git-core/git-sh-prompt ]]; then
		source /usr/lib/git-core/git-sh-prompt
	else
		# Simpler version
		__git_ps1() {
			local s=$?
			if exists git; then
				git branch 2>/dev/null |
				grep '^*' |
				sed 's/* \(.*\)/\1 /'
			fi
			return "$s"
		}
	fi
fi

# Colors
# '\[' and '\]' are for PS1, not colors: https://mywiki.wooledge.org/BashFAQ/053
color() { printf '\['; tput setaf "${1:-15}"; printf '\]'; }
declare -A c=(
	 [BLACK]=$(color 0)  # "\[\e[30m\]"
	   [RED]=$(color 1)  # "\[\e[31m\]"
	 [GREEN]=$(color 2)  # "\[\e[32m\]"
	[YELLOW]=$(color 3)  # "\[\e[33m\]"
	  [BLUE]=$(color 4)  # "\[\e[34m\]"
	[PURPLE]=$(color 5)  # "\[\e[35m\]"
	  [CYAN]=$(color 6)  # "\[\e[36m\]"
	 [WHITE]=$(color 7)  # "\[\e[37m\]"
	  [BOLD]="\[$(tput bold)\]"  # "\[\e[1m\]"
	 [RESET]="\[$(tput sgr0)\]"  # "\[\e[0m\]"
)

# Final product
PS1=${c[RESET]}${c[BOLD]}\
"${c[PURPLE]}\t ${c[GREEN]}\u@\h ${c[BLUE]}\w "\
"${c[RED]}\$(__git_ps1 '%s ')${c[YELLOW]}\$(_format_exitcode)${c[BLUE]}\\$ "\
${c[RESET]}

unset color c

# <<<<<------------------------------------------------------------------------
# Settings --------------------------------------------------------------------

# Disable the dreaded history expansion for interactive sessions
# A.K.A 'why echo "foo!bar" do not work?' (but "foo!" and "foo! bar!" does)
set +o histexpand  # same as set +H

# -----------------------------------------------------------------------------

# https://github.com/dustinkirkland/byobu/pull/57
if exists byobu && ! [[ -d "${XDG_DATA_HOME:-$HOME/.local/share}/byobu" ]]; then
	mkdir -p -- "${XDG_DATA_HOME:-$HOME/.local/share}/byobu"
fi

# So cute!
if exists cowfortune;  then
	cowfortune | { if exists lolcat; then lolcat; else cat; fi; }
fi

# So useful!
if exists neofetch; then neofetch; fi
